ifdef $(DLPATH)
  $(DLPATH):=$($(DLPATH)):$(DLPATH_ADD)
else
  $(DLPATH):=$(DLPATH_ADD)
endif

LIBDIR=lib

QUIET_CC  = @echo '   ' CC  ' ' $@;
# QUIET_CXX = @echo '   ' CXX ' ' $@;
QUIET_AR  = @echo '   ' AR  ' ' $@;

AT=@

SRC_PATH = ./src
INC_PATH = ./src

BUILD_DIRS = $(SRC_PATH)\
	     $(SRC_PATH)/base\
	     $(SRC_PATH)/numbers\
	     $(SRC_PATH)/polynomials\
	     $(SRC_PATH)/tstar\
	     $(SRC_PATH)/caches\
	     $(SRC_PATH)/geometry\
	     $(SRC_PATH)/ISSAC20\
	     $(SRC_PATH)/lists\
	     $(SRC_PATH)/metadatas\
	     $(SRC_PATH)/newton\
	     $(SRC_PATH)/ccluster\
	     $(SRC_PATH)/risolate\
	     $(SRC_PATH)/powerSums\
	     $(SRC_PATH)/doubApp

TEMPLATE_DIRS = 

SOURCES = 
LIB_SOURCES = $(wildcard $(patsubst %, %/*.c, $(BUILD_DIRS)))  $(patsubst %, %/*.c, $(TEMPLATE_DIRS))
LIB_HEADERS = $(foreach x, $(BUILD_DIRS), $(wildcard $(x)/*.h))
# OBJS =        $(patsubst %.c, build/%.o, $(LIB_SOURCES))
# LIB_OBJS =    $(patsubst %, build/%/*.o, $(BUILD_DIRS))
LIB_OBJS=$(LIB_SOURCES:%.c=%.o)
# LIB_OBJS =    $(patsubst %, build/%/*.o, $(LIB_SOURCES))

# LOBJS = $(patsubst %.c, build/%.lo, $(LIB_SOURCES))
LIB_LOBJS=$(LIB_SOURCES:%.c=%.lo)
# LIB_LOBJS = $(patsubst %, build/%/*.lo, $(BUILD_DIRS))
# LIB_LOBJS = $(patsubst %, build/%/*.lo, $(LIB_SOURCES))

BENCHS_DIR = ./benchs
BENCHS_SOURCES = $(wildcard $(patsubst %, %/*.c, $(BENCHS_DIR)))
BENCHS_HEADERS = $(wildcard $(patsubst %, %/*.h, $(BENCHS_DIR)))
BENCHS_OBJS = $(BENCHS_SOURCES:%.c=%.o)
BENCHS_EXE = $(BENCHS_SOURCES:%.c=%)

EXAMPLES_DIR = ./examples

export


all: library bins autotest

################## This part runs a bunch of non-trivial tests #########################
BGREEN = "\e[1;32m"
BRED = "\e[1;31m"
NORMAL = "\e[0m"

exampleFiles: library bins
	bin/genPolFile Mandelbrot 1 7 bin/Mandelbrot_7.ccl >/dev/null
	bin/genPolFile Mignotte 1 128 14 bin/Mignotte_128_14.ccl >/dev/null
	bin/genPolFile Mignotte 1 511 14 bin/Mignotte_511_14.ccl >/dev/null
	bin/genPolFile Bernoulli 1 32 bin/Bernoulli_32.ccl >/dev/null
	
test: library bins exampleFiles
	
	@echo -e $(BGREEN) "Clustering complex roots of a Mandelbrot polynomial of degree 127: should take a few seconds"
	@echo -e $(BRED) "when calling ccluster with no option, a brief recall of usage is diplayed:" $(NORMAL)
	bin/ccluster bin/Mandelbrot_7.ccl
	@echo -e $(BGREEN) "Isolating real roots of a Mandelbrot polynomial of degree 127: should take about a seconds"
	@echo -e $(BRED) "risolate is the binary for real root isolation" $(NORMAL)
	@echo -e $(BRED) "with option -o, one can specify the number of digits for displaying the clusters" $(NORMAL)
	bin/risolate bin/Mandelbrot_7.ccl -o 5
	@echo -e $(BGREEN) "Clustering complex roots of a Mignotte polynomial of degree 128 and bitsize 14: should take a few seconds" $(NORMAL)
	@echo -e $(BRED) "by defaults, ccluster computes clusters without size constraints (i.e. option -e +inf)" $(NORMAL)
	@echo -e $(BRED) "notice the use of option -o with argument 0 for avoiding the output of clusters" $(NORMAL)
	bin/ccluster bin/Mignotte_128_14.ccl -o 0
	@echo -e $(BGREEN) "Computing Clusters of complex roots of size less than 2^-1000 of a Mignotte polynomial of degree 128 and bitsize 14: should be a bit slower, and should isolate the roots" $(NORMAL)
	@echo -e $(BRED) "option -e precision where precision is given as the log in basis 2 of the maximum size of the clusters" $(NORMAL)
	bin/ccluster bin/Mignotte_128_14.ccl -e -1000 -o 0
	@echo -e $(BGREEN) "Isolating real roots of a Mignotte polynomial of degree 128 and bitsize 14: should take about a seconds" $(NORMAL)
	bin/risolate bin/Mignotte_128_14.ccl -o 0
	@echo -e $(BGREEN) "Isolating real roots of a Mignotte polynomial of degree 511 and bitsize 14: should take less than a minute" $(NORMAL)
	bin/risolate bin/Mignotte_511_14.ccl -o 0
	@echo -e $(BGREEN) "Local clustering of complex roots of a Mignotte polynomial of degree 511 and bitsize 14 in [-1,1]+i[-1,1]: should take less than a second" $(NORMAL)
	@echo -e $(BRED) "option -d to specify a square complex box of interest" $(NORMAL)
	bin/ccluster bin/Mignotte_511_14.ccl -d 0,1,0,1,1,1
	@echo -e $(BGREEN) "Clustering complex roots of a Bernoulli polynomial of degree 32: should take less than a second" $(NORMAL)
	@echo -e $(BRED) "for a graphical output, use option -o -2 and pipe to gnuplot" $(NORMAL)
	@echo -e $(BRED) "this test will stop with an error if you do not have gnuplot installed on your machine" $(NORMAL)
	@echo -e $(BRED) "if gnuplot opens a window, close the window to continue" $(NORMAL)
	bin/ccluster bin/Bernoulli_32.ccl -o -2 | gnuplot
	@echo -e $(BGREEN) "Clustering complex roots of a Bernoulli polynomial of degree 32: should take less than a second" $(NORMAL)
	@echo -e $(BRED) "for a graphical output with the subdivision tree, use option -o -3 and pipe to gnuplot" $(NORMAL)
	bin/ccluster bin/Bernoulli_32.ccl -o -3 | gnuplot

################## End tests ######################################################


quiet: library

verbose:
# 	$(MAKE) AT= QUIET_CC= QUIET_CXX= QUIET_AR=
	$(MAKE) AT= QUIET_CC= QUIET_AR=

clean: 
	@echo "Cleaning all"
	rm -rf $(LIB_OBJS) $(LIB_LOBJS) libccluster.a $(CCLUSTER_LIB) \
	$(CCLUSTER_LIBNAME) $(CCLUSTER_LIBNAME).$(CCLUSTER_MAJOR) 
	rm -rf build
	cd bin && make clean && cd ..
# 	$(wildcard $(CCLUSTER_LIBNAME)*)

distclean: clean benchsclean testclean
	rm -f Makefile
	rm -f test/Makefile
	rm -f bin/Makefile
	rm -f bin/ISSAC20/Makefile
	
$(CCLUSTER_LIB): $(LIB_LOBJS) $(LIB_SOURCES) $(LIB_HEADERS)
	@echo "Building $@"
	$(CC) $(CFLAGS) -o $@ -shared $(LIB_LOBJS) $(LIBS2) ;
	ln -sf "$(CCLUSTER_LIB)" "$(CCLUSTER_LIBNAME)"; \
	ln -sf "$(CCLUSTER_LIB)" "$(CCLUSTER_LIBNAME).$(CCLUSTER_MAJOR)"; \

libccluster.a: $(LIB_OBJS) $(LIB_SOURCES) $(LIB_HEADERS)
	$(AR) rcs libccluster.a $(LIB_OBJS)
	
# build/%.lo: %.c $(HEADERS) | build
# 	$(QUIET_CC) $(CC) $(PIC_FLAG) $(CFLAGS) $(INCS) -I$(INC_PATH) -c $< -o $@;
# 
# build/%.o: %.c $(HEADERS) | build
# 	$(QUIET_CC) $(CC) $(CFLAGS) $(INCS) -I$(INC_PATH) -c $< -o $@;

%.lo : %.c $(HEADERS)
# 	@echo "Building $@"
	$(QUIET_CC) $(CC) $(PIC_FLAG) $(DFLAGS) $(CFLAGS) $(INCS) -c $< -o $@;
	
%.o : %.c $(HEADERS)
# 	@echo "Building $@"
	$(QUIET_CC) $(CC) $(DFLAGS) $(CFLAGS) $(INCS) -c $< -o $@;

library:
	$(eval HEADERS=$(LIB_HEADERS))
	$(AT)if [ "$(CCLUSTER_SHARED)" -eq "1" ]; then \
		$(MAKE) shared; \
	fi
	$(AT)if [ "$(CCLUSTER_STATIC)" -eq "1" ]; then \
		$(MAKE) static; \
	fi

shared: $(CCLUSTER_LIB)

static: libccluster.a
	
install: library
	mkdir -p $(DESTDIR)$(PREFIX)/$(LIBDIR)
	mkdir -p $(DESTDIR)$(PREFIX)/include
	$(AT)if [ "$(CCLUSTER_SHARED)" -eq "1" ]; then \
		cp $(CCLUSTER_LIB) "$(DESTDIR)$(PREFIX)/$(LIBDIR)"; \
		cp -a $(shell ls $(CCLUSTER_LIBNAME)*) "$(DESTDIR)$(PREFIX)/$(LIBDIR)"; \
	fi
	$(AT)if [ "$(CCLUSTER_STATIC)" -eq "1" ]; then \
		cp libccluster.a $(DESTDIR)$(PREFIX)/$(LIBDIR); \
	fi
	mkdir -p include
	cp -r src/* include
	rm -f include/*/*.o include/*/*.lo include/*/*.c
	mkdir -p $(DESTDIR)$(PREFIX)/include/ccluster
	cp -r include/* $(DESTDIR)$(PREFIX)/include/ccluster/
	rm -r include
# 	cp $(LIB_HEADERS) $(DESTDIR)$(PREFIX)/include
# 	$(AT)if [ ! -z $(EXT_HEADERS) ]; then \
# 		cp $(EXT_HEADERS) $(DESTDIR)$(PREFIX)/include; \
# 	fi

compbenchs: library comptest
	cd benchs && make build && cd ..
	
comptest: library
	cd test && make build && cd ..

bins: library
	cd bin && make && cd ..
	
# test: comptest bins
# 	cd test && make tM1 && cd ..
	
autotest: bins
	cd bin && make test && cd ..
	
ISSAC: bins
	cd bin/ISSAC20 && make && make test && cd ../..
	
benchICMS: compbenchs
	cd benchs && make tableICMS && cd ..
	
testclean: 
	cd test && make clean && cd ..
	
benchsclean: 
	cd benchs && make clean && make cleanBenchs && cd ..
	
print-%:
	@echo '$*=$($*)'
	
# print: 
# 	@echo "BUILD_DIRS:  " $(BUILD_DIRS)
# 	@echo "LIB_SOURCES: " $(LIB_SOURCES)
# 	@echo "HEADERS:     " $(HEADERS)
# 	@echo "OBJS:        " $(OBJS)
# 	@echo "LIB_OBJS:    " $(LIB_OBJS)
# 	@echo "LIB_OBJS:    " $(LIB_OBJS)
